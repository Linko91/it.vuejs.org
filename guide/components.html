
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Componenti - vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js - Libreria intuitiva, veloce per costruire interfacce interattive tramite MVVM.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,600|Roboto Mono' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Dosis:300,500&text=Vue.js' rel='stylesheet' type='text/css'>
        <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
        <link rel="icon" href="/images/logo.png" type="image/x-icon">
        <script>
            window.PAGE_TYPE = "guida"
        </script>
        <link rel="stylesheet" href="/css/page.css">
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46852172-1', 'vuejs.org');
  ga('send', 'pageview');
</script>
        <script src="/js/vue.js"></script>
    </head>
    <body>
        <div id="mobile-bar">
            <a class="menu-button"></a>
            <a class="logo" href="/"></a>
        </div>
        
            <div id="header">
    <a id="logo" href="/">
        <img src="/images/logo.png">
        <span>Vue.js</span>
    </a>
    <ul id="nav">
        <li>
  <form id="search-form">
    <input type="text" id="search-query" class="st-default-search-input">
  </form>
</li>
<li><a href="/guide/" class="nav-link current">Guida</a></li>
<li><a href="/api/" class="nav-link">API</a></li>
<li><a href="/examples/" class="nav-link">Esempi</a></li>
<li><a href="/blog/" class="nav-link">Blog</a></li>
<li class="nav-dropdown-container">
  <a class="nav-link">Community</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://github.com/vuejs/vue" class="nav-link" target="_blank">GitHub</a></li>
    <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">Forum</a></li>
    <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">Chat</a></li>
    <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
  </ul>
</li>


    </ul>
</div>
            <div id="main">
                
                    
    <div class="sidebar">
    <ul class="main-menu">
        <li>
  <form id="search-form">
    <input type="text" id="search-query" class="st-default-search-input">
  </form>
</li>
<li><a href="/guide/" class="nav-link current">Guida</a></li>
<li><a href="/api/" class="nav-link">API</a></li>
<li><a href="/examples/" class="nav-link">Esempi</a></li>
<li><a href="/blog/" class="nav-link">Blog</a></li>
<li class="nav-dropdown-container">
  <a class="nav-link">Community</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://github.com/vuejs/vue" class="nav-link" target="_blank">GitHub</a></li>
    <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">Forum</a></li>
    <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">Chat</a></li>
    <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
  </ul>
</li>


    </ul>
    <div class="list">
        <div id="donate" style="margin-bottom: 20px">
            <span class="wrapper" style="width: 110px">
                <img src="/images/patreon.png">
                <a href="/support-vuejs">Dona a Vue.js</a>
            </span>
         </div>
        <h2>
            Guida
            <select class="version-select">
                <option selected>1.0.*</option>
                <option>0.12</option>
                <option>0.11</option>
            </select>
        </h2>
        <ul class="menu-root">
            
                <li>
                    <a href="/guide/installation.html" class="sidebar-link">Installazione</a>
                </li>
            
                <li>
                    <a href="/guide/index.html" class="sidebar-link">Per Iniziare</a>
                </li>
            
                <li>
                    <a href="/guide/overview.html" class="sidebar-link">Panoramica</a>
                </li>
            
                <li>
                    <a href="/guide/instance.html" class="sidebar-link">L'instanza di Vue</a>
                </li>
            
                <li>
                    <a href="/guide/syntax.html" class="sidebar-link">Two Way Binding nel Dettaglio</a>
                </li>
            
                <li>
                    <a href="/guide/computed.html" class="sidebar-link">Proprietà Derivate</a>
                </li>
            
                <li>
                    <a href="/guide/class-and-style.html" class="sidebar-link">Vincolo sul CSS</a>
                </li>
            
                <li>
                    <a href="/guide/conditional.html" class="sidebar-link">Rendering Condizionato</a>
                </li>
            
                <li>
                    <a href="/guide/list.html" class="sidebar-link">Rendering di Liste</a>
                </li>
            
                <li>
                    <a href="/guide/events.html" class="sidebar-link">Gestione degli Eventi e dei Metodi</a>
                </li>
            
                <li>
                    <a href="/guide/forms.html" class="sidebar-link">Vincolo sugli input dei Form</a>
                </li>
            
                <li>
                    <a href="/guide/transitions.html" class="sidebar-link">Transizioni</a>
                </li>
            
                <li>
                    <a href="/guide/components.html" class="sidebar-link current">Componenti</a>
                </li>
            
                <li>
                    <a href="/guide/reactivity.html" class="sidebar-link">Reattività nel Dettaglio</a>
                </li>
            
                <li>
                    <a href="/guide/custom-directive.html" class="sidebar-link">Direttive Personalizzate</a>
                </li>
            
                <li>
                    <a href="/guide/custom-filter.html" class="sidebar-link">Filtri Personalizzati</a>
                </li>
            
                <li>
                    <a href="/guide/mixins.html" class="sidebar-link">Mixins</a>
                </li>
            
                <li>
                    <a href="/guide/plugins.html" class="sidebar-link">Plugins</a>
                </li>
            
                <li>
                    <a href="/guide/application.html" class="sidebar-link">Costruire un'Applicazione scalabile</a>
                </li>
            
                <li>
                    <a href="/guide/comparison.html" class="sidebar-link">Confronto con altri Framework</a>
                </li>
            
        </ul>
    </div>
</div>


<div class="content guida with-sidebar">
    <div id="ad">
  <a href="https://strikingly.com/s/careers?utm_source=v" target="_blank">
    <span>Fieramente Sponsorizzato da</span><br>
    <img src="/images/strikingly.png">
  </a>
</div>

    <h1>Componenti</h1>
    <h2 id="Che-cos’e-un-componente"><a href="#Che-cos’e-un-componente" class="headerlink" title="Che cos’è un componente?"></a>Che cos’è un componente?</h2><p>In componente è la caratteristica più interessante di Vue.js, ed è anche lo strumento più potente.<br>I componenti aiutano ad estendere il classico DOM HTML con dei blocchi di codice riutilizzabile<br>In altre parole, i componenti sono elementi personalizzati, contenenti un template HTML,  che Vue.js compila e renderizza come elementi del DOM.<br>In alcuni cassi essi possono apparire come elementi nativi HTML con un attributo speciale chiamato <code>is</code>.</p>
<h2 id="Utilizzare-i-Componenti"><a href="#Utilizzare-i-Componenti" class="headerlink" title="Utilizzare i Componenti"></a>Utilizzare i Componenti</h2><h3 id="Registrazione"><a href="#Registrazione" class="headerlink" title="Registrazione"></a>Registrazione</h3><p>Nelle sezioni precedenti abbiamo imparato a costruire dei componenti personalizzati tramite il costruttore <code>Vue.extend()</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  <span class="comment">// opzioni...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Per utilizzarlo come un componente, dovete <strong>registrarlo</strong> tramite la funzione <code>Vue.component(tag, constructor)</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Componente registrato a livello globale con il tag my-component</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</span><br></pre></td></tr></table></figure>
<p class="tip">Nota: Vue.js non ti forza ad utilizzare le <a href="http://www.w3.org/TR/custom-elements/#concepts" target="_blank" rel="external">regole W3C</a> per i nomi dei tag personalizzati, anche se rispettare tali regole è considerata cosa buona e giusta.</p>

<p>Una volta registrato il componente, può essere utilizzato nell’istanza di Vue tramite il tag <code>&lt;my-component&gt;</code>. Assicuratevi che il componente sia registrato <strong>prima</strong> della vostra istanza di Vue. Ecco un esempio completo:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// definizione</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Un componente custom!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// registrazione</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// creazione dell'istanza</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Renderizzato diventerà:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Un componente custom!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Un componente custom!</div>'
})
new Vue({ el: '#example' })
</script>

<p>Da notare come il template del componente <strong>rimpiazzi</strong> il tag personalizzato, il quale serve solo come <strong>riferimento</strong> per lo sviluppatore. Il comportamento in fase di rimpiazzamento può essere gestito tramite l’opzione <code>replace</code>.</p>
<h3 id="Registrazione-Locale"><a href="#Registrazione-Locale" class="headerlink" title="Registrazione Locale"></a>Registrazione Locale</h3><p>Non dovete per forza registrare ogni componente in modo globale. Potete anche creare dei componenti che esistono solo all interno di un altro componente registrandolo internamente:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; sarà disponibile solo all interno del template del padre</span></span><br><span class="line">    <span class="string">'my-component'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Questa logica può essere utilizzata per altri scopi, per esempio incapsulamento di direttive, filtri e transizioni.</p>
<h3 id="Facilitare-la-Registrazione"><a href="#Facilitare-la-Registrazione" class="headerlink" title="Facilitare la Registrazione"></a>Facilitare la Registrazione</h3><p>Per rendervi le cose ancora più facili, potete passare le opzioni direttamente alla funzione <code>Vue.component()</code> invece di utilizzare un costruttore separato.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Un solo step per la registrazione</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// funziona anche per le registrazioni locali</span></span><br><span class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: &#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Opzioni-dei-Componenti"><a href="#Opzioni-dei-Componenti" class="headerlink" title="Opzioni dei Componenti"></a>Opzioni dei Componenti</h3><p>Molte delle opzioni passate al costruttore del componente possono essere utilizzate direttamente tramite <code>Vue.extend()</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Il problema di questo approccio è che l oggetto <code>data</code> sarà condiviso con tutte le istanze del componente stesso! Questo comportamento non è quello che ci aspettiamo da un componente, il quale dovrebbe avere tutto incapsulato, per risolvere questo problema possiamo specificare una funzione per il nostro oggetto <code>data</code> la quale restituisce un oggetto nuovo:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Questo discorso vale anche per l’opzione <code>el</code>, in quanto vige lo stesso problema di condivizione.</p>
<h3 id="Parsing-del-Template"><a href="#Parsing-del-Template" class="headerlink" title="Parsing del Template"></a>Parsing del Template</h3><p>Il motore dietro al sistem di gestione dei template in Vue.js è basato sul DOM ed utilizzare dei parser nativi del browser invece di creare di nuovi. Questo porta sia dei vantaggi, soprattutto se compariamo questo sistemo ad un classico sistema di renderizzazione basato su stringhe, ma anche alcune regole da tenere a mente per esempio, il template dev’essere sempre composto da HTML valido e seguire le classiche regole su “chi contiene cosa”, in particolare:</p>
<ul>
<li>L’elemento <code>a</code> non può contenere altri elementi interattivi (come bottoni o link)</li>
<li>L’elemento <code>li</code> deve essere figlio diretto del elemento <code>ul</code> o <code>ol</code>, e sia <code>ul</code> che <code>ol</code> possono solo contenere <code>li</code></li>
<li>L’elemento <code>option</code> deve essere figlio diretto di <code>select</code>, di conseguenza <code>select</code> può solo contenere <code>option</code> o <code>optgroup</code></li>
<li>L’elemento <code>table</code> deve contenere solo <code>thead</code>, <code>tbody</code>, <code>tfoot</code> e <code>tr</code>, tutti questi elementi devono essere figli diretti di <code>table</code></li>
<li>L’elemento <code>tr</code> può solo contenere <code>th</code> e <code>td</code>, e questi due elementi devono essere figli diretti di <code>tr</code></li>
</ul>
<p>Queste restrizioni esistono per evitare comportamenti del DOM inaspettati. Anche se alcune casistiche, se non rispettate, possono dare l’idea di funzionare, non potete fare affidamento su come il browser possa validare i componenti custom con elementi errati, per esempio <code>&lt;my-select&gt;&lt;option&gt;...&lt;/option&gt;&lt;/my-select&gt;</code> non è un template valido anche se <code>my-select</code> potrebbe espandersi in <code>&lt;select&gt;...&lt;/select&gt;</code>.</p>
<p>Un’altra conseguenza che può portare ad un ordine improprio degli elementi è l’utilizzo tag personalizzati (come <code>&lt;component&gt;</code>, <code>&lt;template&gt;</code> e <code>&lt;partial&gt;</code>) internamente ad <code>ul</code>, <code>select</code>, <code>table</code> e altri elementi con  restrizioni simili dato che tali tag verrebbero renderizzati in modo errato dal browser.</p>
<p>Se dovete utilizzare un elemento personalizzato dovete far affidamento all’attributo speciale <code>is</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-component"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Nel caso di un <code>&lt;template&gt;</code> dentro una <code>&lt;table&gt;</code> conviene usare <code>&lt;tbody&gt;</code>, come tabelle e creare più <code>tbody</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>Riga pari<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>Riga dispari<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h3 id="Passaggio-dei-Dati-tramite-i-Props"><a href="#Passaggio-dei-Dati-tramite-i-Props" class="headerlink" title="Passaggio dei Dati tramite i Props"></a>Passaggio dei Dati tramite i Props</h3><p>Tutti i componenti hanno una loro istanza <strong>isolata</strong>. Questo significa che non potete (e non dovreste) referenziare i dati di un componente padre internamente al figlio. I dati però possono essere passati tra le istanze correlate tramite i <strong>props</strong>.</p>
<p>Un “prop”, detta anche proprietà di sostengo, è un campo all interno del componento che si aspetta o che intende condividere, se è un componente padre a sua volta. Un componente deve dichiaratamente esprimere quali dati vuole che gli vengano passati, per farlo deve utilizzare <a href="/api/#props">l’opzione <code>prop</code></a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// Dichiariamo il prop</span></span><br><span class="line">  props: [<span class="string">'msg'</span>],</span><br><span class="line">  <span class="comment">// Il prop può essere usato internamente nel template</span></span><br><span class="line">  <span class="comment">// E in tutta l'istanza del componente con this.</span></span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Successivamente possiamo usarlo come sempre:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">msg</span>=<span class="string">"Ciao!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Risultato:</strong></p>

<div id="prop-example-1" class="demo">
  <child msg="Ciao!"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['msg'],
      template: '<span>{{ msg }}</span>'
    }
  }
})
</script>

<h3 id="camelCase-vs-kebab-case"><a href="#camelCase-vs-kebab-case" class="headerlink" title="camelCase vs. kebab-case"></a>camelCase vs. kebab-case</h3><p>Nel linguaggio HTML gli attributi sono insensibili alla capitalizzazione. Quando si utilizzano i prop come attributi è conveniente usare la notazione kebab-case, come nell esempio:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// camelCase in JavaScript</span></span><br><span class="line">  props: [<span class="string">'myMessage'</span>],</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- kebab-case in HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"Ciao!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Props-Dinamici"><a href="#Props-Dinamici" class="headerlink" title="Props Dinamici"></a>Props Dinamici</h3><p>Come abbiamo già visto è possibile vincolare ad un attributo una particolare espressione, con <code>v-bind</code> possiamo anche vincolare i props in modo dinamico, i quali verrano aggiornati ogni volta che il dato di origine, quello padre, verrà aggiornato:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentMsg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>E’ sempre comodo usare le scorciatoie di sintassi, per <code>v-bind</code> abbiamo:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Risultato:</strong></p>

<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Message from parent'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{myMessage}}</span>'
    }
  }
})
</script>

<h3 id="Dinamico-vs-Non-Dinamico"><a href="#Dinamico-vs-Non-Dinamico" class="headerlink" title="Dinamico vs Non Dinamico"></a>Dinamico vs Non Dinamico</h3><p>Un errore comune, soprattutto agli inizi, è quello di passare un numero fisso ad un attributo, come in questo esempio:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Viene passato 1 come stringa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Però, essendo questo un prop non dinamico, il valore verrà passato proprio come stringa <code>&quot;1&quot;</code>, invece che come numero. Se volete passare un numero vero e proprio, dobbiamo utilizzare la sintassi dinamica vistra precedentemente:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- In questo modo si passa un numero --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Tipo-di-Vincolo-dei-Prop"><a href="#Tipo-di-Vincolo-dei-Prop" class="headerlink" title="Tipo di Vincolo dei Prop"></a>Tipo di Vincolo dei Prop</h3><p>Per definizione, tutti i prop hanno un vincolo <strong>mono direzionale</strong> tra il padre ed il figlio: quando l’attributo padre viene aggiornato, il prop figlio viene aggiornato di conseguenza ma non viceversa. Questo comportamento standard previene eventuali mutamenti dello stato corrente della proprietà del padre, mutamenti accidentali che possono essere scatenati da componenti figli. Potrà sembrare restrittivo, per questo Vuejs permette di <strong>modificare questo vincoli</strong> tramite dei modificatori come <code>.sync</code> e <code>.once</code>:</p>
<p>Ecco la sintassi:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- default, vincolo mono direzionale --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vincolo bidirezionale esplicito --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg.sync</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vincolo bidirezionale esplicito che occorre una volta --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg.once</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Il vincolo a due direzioni sincronizzerà lo stato della proprietà <code>msg</code> con quella del padre <code>parentMsg</code>. Il vincolo bidirezionale esplicito che occorre una volta sola sincronizzerà le due proprietà ma solo alla prima occasione.</p>
<p class="tip">Attenzione, se il prop che viene passato è un Oggetto od un Array, verrà passato per referenza. Modificare un Oggetto o l’Array internamente al figlio <strong>muterà</strong> anche la properità del padre indipendentemente dal tipo di vincolo che state utilizzando</p>

<h3 id="Validazione-dei-Prop"><a href="#Validazione-dei-Prop" class="headerlink" title="Validazione dei Prop"></a>Validazione dei Prop</h3><p>E’ possibile, per un componente, specificare i requisiti di validazione di ogni prop. Questo è molto utile quando i prop di un componente verranno utilizzati da altri, dato che questo tipo di validazione sostanzialmente costuisce le fondamente di API per il componente stesso, e rafforza il buon uso del componente stesso. Per attivare le validazioni bisogna trattare la properità prop come un insieme di oggetti:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// Tipo richiesto (`null` significa qualsiasi tipo)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// Tipi multipli (1.0.21+)</span></span><br><span class="line">    propM: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// Una stringa richiesta</span></span><br><span class="line">    propB: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Un numero con un valore di default</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Un oggetto con una funzione per creare un oggetto di default</span></span><br><span class="line">    <span class="comment">// Questo concetto va applicato anche per gli Array</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; msg: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Indica che questo prop si aspetta un vincolo bidirezionale, se non lo trova</span></span><br><span class="line">    <span class="comment">// Scatenerà dei warning.</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      twoWay: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Validazione personalizzata</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Funzione di coerenza (novità dalla 1.0.12)</span></span><br><span class="line">    <span class="comment">// Rafforza il tipo di dato prima di assegnarlo al prop</span></span><br><span class="line">    propG: &#123;</span><br><span class="line">      coerce: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val + <span class="string">''</span> <span class="comment">// cast the value to string</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    propH: &#123;</span><br><span class="line">      coerce: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(val) <span class="comment">// mutiamo il typo ad Oggetto</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>I tipi di dato disponibili sono:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Function</li>
<li>Object</li>
<li>Array</li>
</ul>
<p>In aggiunta si può definire la proprietà <code>type</code> con una funzione la quale conterrà un controllo utilizzando <code>instanceof</code>, molto utile per i tipi di dato personalizzati.</p>
<p>Quando una validazione fallisce, Vue si rifiuterà di impostare il valore, e lancerà un warning se si sta utilizzando la build per gli sviluppatori.</p>
<h2 id="Comunicazione-Padre-Figlio"><a href="#Comunicazione-Padre-Figlio" class="headerlink" title="Comunicazione Padre-Figlio"></a>Comunicazione Padre-Figlio</h2><h3 id="La-Catena-dei-Padri"><a href="#La-Catena-dei-Padri" class="headerlink" title="La Catena dei Padri"></a>La Catena dei Padri</h3><p>Un componente figlio ha accesso al componente padre tramite l’utilizzo di <code>this.$parent</code>. Un’istanza Vue è disponibile a tutti i componenti e i loro discendenti tramite <code>this.$root</code>. Ogni padre ha un Array di componenti figli in un array <code>this.$children</code>.</p>
<p>Anche se questa logica rendere virtualmente possibile l’accesso alla catena dei padri da parte di un eventuale figlio, è vivamente sconsigliata e, invece, dovreste sempre passare i dati in modo esplicito tramite i prop. In aggiunta al discorso, è una cattiva abitudine quella di mutare lo stato di un componente padre da parte di un figlio per i seguenti motivi:</p>
<ol>
<li><p>Rende il legame padre e figlio strettamente dipendenti;</p>
</li>
<li><p>Rende difficile stabilire lo stato corrente del padre senza dipendere dagli stati di eventuali figli! In un sistema ideale lo stato di ogni componente dev’essere auto gestito.</p>
</li>
</ol>
<h3 id="Eventi-Personalizzati"><a href="#Eventi-Personalizzati" class="headerlink" title="Eventi Personalizzati"></a>Eventi Personalizzati</h3><p>Tutte le istanze di Vue implementano un’interfaccia per facilitare la comunicazione tra gli eventi di ogni componente. Questo sistema di eventi è indipendente dal sitema degli eventi legati al DOM e lavora in modo differente.</p>
<p>Tutte le istanze di Vue possono:</p>
<ul>
<li><p>Ascoltare gli eventi tramite <code>$on()</code>;</p>
</li>
<li><p>Attivare gli eventi da soli utilizzando <code>$emit()</code>;</p>
</li>
<li><p>Spedire gli eventi che si propagano per tutta la catena dei padri tramite <code>$dispatch()</code>;</p>
</li>
<li><p>Trasmettere gli eventi a tutti i discendenti tramite <code>$broadcast()</code>.</p>
</li>
</ul>
<p class="tip">Al contrario degli eventi DOM, gli eventi un Vue verranno automaticamente fermati una volta che la propagazione raggiunte il callback finale, a meno che tale callback non abbia un <code>return true</code> alla fine.</p>

<p>Un semplice esempio:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Template, componente figlio --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child-template"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"notify"</span>&gt;</span>Invia Evento<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Template, componente padre --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"events-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Messages: &#123;&#123; messages | json &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Registriamo il figlio che poi invierà l'Evento</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#child-template'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; msg: <span class="string">'Ciao'</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    notify: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.msg.trim()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$dispatch(<span class="string">'child-msg'</span>, <span class="keyword">this</span>.msg)</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creiamo il padre, che riceverà il messaggio in un array</span></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#events-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    messages: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// l'opzione `events` chiamerà `$on()` per voi quando l'istanza verrà creata</span></span><br><span class="line">  events: &#123;</span><br><span class="line">    <span class="string">'child-msg'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` è legato all'istanza corrente in automatico</span></span><br><span class="line">      <span class="keyword">this</span>.messages.push(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<script type="x/template" id="child-template">
  <input v-model="msg">
  <button v-on:click="notify">Invia Evento</button>
</script>

<div id="events-example" class="demo">
  <p>Messages: {{ messages | json }}</p>
  <child></child>
</div>
<script>
Vue.component('child', {
  template: '#child-template',
  data: function () {
    return { msg: 'Ciao' }
  },
  methods: {
    notify: function () {
      if (this.msg.trim()) {
        this.$dispatch('child-msg', this.msg)
        this.msg = ''
      }
    }
  }
})

var parent = new Vue({
  el: '#events-example',
  data: {
    messages: []
  },
  events: {
    'child-msg': function (msg) {
      this.messages.push(msg)
    }
  }
})
</script>

<h3 id="Eventi-Personalizzati-e-v-on"><a href="#Eventi-Personalizzati-e-v-on" class="headerlink" title="Eventi Personalizzati e v-on"></a>Eventi Personalizzati e v-on</h3><p>L’esempio sopra citato è un buon inizio, ma se guardate attentamente il codice del componente padre, non è chiaro da dove <code>&quot;child-msg&quot;</code> arrivi. Sarebbe meglio se potessimo dichiarare il gestore di quello specifico evento direttamente nel template, dove viene utilizzato dal componente figlio. Per fare ciò  <code>v-on</code> è la soluzione ideale e può essere usato per ascoltare gli eventi che verranno poi utilizzati dai componenti figli:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-on:child-msg</span>=<span class="string">"handleIt"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Questo rende le cose ancora più chiare: quando un figlio attiva <code>&quot;child-msg&quot;</code> allora la funzione <code>handleIt</code> del padre verrà chiamata. Qualsiasi codice o logica che modificherà lo stato del componente padre verrà tenuta incapsulata all’interno del padre stesso, il figlio non dovrà preoccuparsi di nulla.</p>
<h3 id="Riferimenti-ai-Componenti-Figli"><a href="#Riferimenti-ai-Componenti-Figli" class="headerlink" title="Riferimenti ai Componenti Figli"></a>Riferimenti ai Componenti Figli</h3><p>Nonostante ci siano i Prop e gli eventi, a volte può essere ancora necessario accedere direttamente ad un componente figlio tramite JavaScript. Per fare ciò si può assegnare un ID univoco al componente figlio tramite l’utilizzo di <code>v-ref</code>, per esemio:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user-profile</span> <span class="attr">v-ref:profile</span>&gt;</span><span class="tag">&lt;/<span class="name">user-profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; el: <span class="string">'#parent'</span> &#125;)</span><br><span class="line"><span class="comment">// access child component instance</span></span><br><span class="line"><span class="keyword">var</span> child = parent.$refs.profile</span><br></pre></td></tr></table></figure>
<p>Quando <code>v-ref</code> viene usato assieme a <code>v-for</code>, il riferimento diventerà un Array o un Oggetto contenente tutti i componenti figli.</p>
<h2 id="Distribuzione-dei-Contenuti-tramite-Slots"><a href="#Distribuzione-dei-Contenuti-tramite-Slots" class="headerlink" title="Distribuzione dei Contenuti tramite Slots"></a>Distribuzione dei Contenuti tramite Slots</h2><p>Quando si usano dei componenti, molto spesso il risultato è qualcosa di simile:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Ci sono due cose da notare in questo particolare codice:</p>
<ol>
<li><p>Il componente <code>&lt;app&gt;</code> non sa il contenuto che potrà essere presente internamente agli altri componenti è deciso da qualsiasi componente includa <code>&lt;app&gt;</code> stesso.</p>
</li>
<li><p>Il componente <code>&lt;app&gt;</code> probabilmente avrà un suo template.</p>
</li>
</ol>
<p>Per far in modo che la composizione sia efficace, bisogna intervenire sul flusso dei componenti e del loro stesso stemplate. Questo processo viene definito <strong>distribuzione dei contenuti</strong> (o “transclusion” se arrivate dal mondo AngularJS). Vue.js implemente un sistema di distribuzione dei contenuti e fornisce delle API modellate appositamente secondo <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="external">le specifiche dei Componenti Web</a>, utilizzando l elemento speciale <code>&lt;slot&gt;</code> per distribuire tali componenti.</p>
<h3 id="Compilation-Scope"><a href="#Compilation-Scope" class="headerlink" title="Compilation Scope"></a>Compilation Scope</h3><p>Prima di approfondire la nostra consocenze sulle API, chiarifichiamo in quale ambito i contenuti vengono compilati. Immaginate un template del tipo:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In questo caso <code>msg</code> andrebbe vincolato ai dati del padre oppure del figlio? La risposta è del padre, una regola di base per stabilire l’ambito dei componenti è:</p>
<blockquote>
<p>Tutto ciò che viene compilato all’interno dell’ambito del padre appartiene al padre stesso, tutto quello che viene compilato nell’ambito del figlio appartiene al figlio.</p>
</blockquote>
<p>Un esempio di errore molto comunque è quello di cercare di legare una direttiva del figlio a qualche metodo o proprietà del padre:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Non funziona --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-show</span>=<span class="string">"someParentProperty"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Mettiamo caso che <code>someParentProperty</code> sia una proprietà interna del figlio, l’esempio sopra comunque non funzionerebbe come previsto. Il padre non deve essere a conoscenza dello stato del figlio, o per lo meno non dovrebbe preoccuparsene.</p>
<p>Se avete proprio la necessità di legare direttive figlie a qualche componente padre, dovete farlo all’interno della definizione del componente figlio stessa:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// Questo funziona, siamo nell'ambito giusto</span></span><br><span class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      someChildProperty: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Slot-Singolo"><a href="#Slot-Singolo" class="headerlink" title="Slot Singolo"></a>Slot Singolo</h3><p>Il contenuto del padre verrà <strong>scartato</strong> a meno che il componente figlio non contenga almeno un elemento <code>&lt;slot&gt;</code>. Quando viene rilevato un elemento slot, senza contenuti ne attributi, tutto il contenuto del padre andrà a rimpiazzare lo slot stesso.</p>
<p>Se invece c’è del contenuto dentro uno <code>&lt;slot&gt;</code> allora verrà considerato <strong>contenuto di rimpiazzio</strong>. Ciò significa che verrà visualizzato se il padre non ha niente da mostrare.</p>
<p>Supponiamo di avere un componente del tipo:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Questo è un componente!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">    Questo contenuto verrà visualizzato se il padre non ha bisogno dello slot</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Il padre che utilizzerà il componente:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Contenuto originale<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Altro contenuto originale<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Il risultato finale sarà</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Questo è un componente!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Contenuto originale<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Altro contenuto originale<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Slots-Nominativi"><a href="#Slots-Nominativi" class="headerlink" title="Slots Nominativi"></a>Slots Nominativi</h3><p>Gli elementi <code>&lt;slot&gt;</code> hanno un attributo speciale chiamato <code>name</code>, tale attributo può essere utilizzato per personalizzare il contenuto distribuito dagli slot stessi. Puoi avere slot multipli con nomi differenti. Il contenuto di uno slot nominativo viene cercato usando il nome dello slot come referenza.</p>
<p>Possono ancora esistere gli slot anonimi, i quali vengono utilizzati come <strong>slot di default</strong>.</p>
<p>Ecco un esempio di slot multipli:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"two"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Codice del Padre:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">multi-insertion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Default A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">multi-insertion</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Risultato:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Default A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Il sistema degli slot e la distribuzione dei contenuti è un meccanismo utilissimo per comporre template con componenti che interagiscono tra di loro.</p>
<h2 id="Componenti-Dinamici"><a href="#Componenti-Dinamici" class="headerlink" title="Componenti Dinamici"></a>Componenti Dinamici</h2><p>Sfruttando una singla istanza puoi cambiare dinamicamente i componenti utilizzati tramite l’elemento <code>&lt;component&gt;</code> e il suo attributo <code>is</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'body'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: <span class="string">'home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    posts: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    archive: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- il componente cambierà in base al valore di is --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><code>keep-alive</code></h3><p>Nel caso tu voglia mantenere lo stato del componente anche se cambia, in modo da evitare una doppia renderizzazione, puoi utilizzare la direttiva <code>keep-alive</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span> <span class="attr">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- il componente inattivo verrà messo in cache --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Hook-activate"><a href="#Hook-activate" class="headerlink" title="Hook activate"></a>Hook <code>activate</code></h3><p>Quando si cambiano componenti, ed il componente in arrivo deve fare qualche lavoro asincrono prima di essere renderizzato, si può sfruttare l hook <code>activate</code> per gestire quel frangente tra il richiamo e la renderizzazione:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'activate-example'</span>, &#123;</span><br><span class="line">  activate: <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    loadDataAsync(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      self.someData = data</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Da notare che questo <code>activate</code> viene chiamato solo durante il cambio di componenti o al primo richiamo del componente stesso. Non viene chiamato se viene inserito all interno di un’istanza Vue.</p>
<h3 id="transition-mode"><a href="#transition-mode" class="headerlink" title="transition-mode"></a><code>transition-mode</code></h3><p>L attributo <code>transition-mode</code> vi permette di specificare in che modo avvenga il cambio di due o più componenti dinamici.</p>
<p>Per definizione, la transizione avviene in modo simultaneo. Questo però non vi impedisce di provare altri due modi disponibili:</p>
<ul>
<li><p><code>in-out</code>: Il nuovo componente entra per primo, il componente che deve svanire lo fa finita la transizione del nuovo componente.</p>
</li>
<li><p><code>out-in</code>: Il componente attuale esce di scena per primo, il nuovo componente apparirà quando la transizione è finita.</p>
</li>
</ul>
<p><strong>Esempio</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- fade out prima, poi fade in --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span></span><br><span class="line">  <span class="attr">:is</span>=<span class="string">"view"</span></span><br><span class="line">  <span class="attr">transition</span>=<span class="string">"fade"</span></span><br><span class="line">  <span class="attr">transition-mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade-transition</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="transition-mode-demo" class="demo">
  <input v-model="view" type="radio" value="v-a" id="a" name="view"><label for="a">A</label>
  <input v-model="view" type="radio" value="v-b" id="b" name="view"><label for="b">B</label>
  <component :is="view" transition="fade" transition-mode="out-in">
  </component>
</div>
<style>
  .fade-transition {
    transition: opacity .3s ease;
  }
  .fade-enter, .fade-leave {
    opacity: 0;
  }
</style>
<script>
new Vue({
  el: '#transition-mode-demo',
  data: {
    view: 'v-a'
  },
  components: {
    'v-a': {
      template: '<div>Component A</div>'
    },
    'v-b': {
      template: '<div>Component B</div>'
    }
  }
})
</script>

<h2 id="Altri-Particolari"><a href="#Altri-Particolari" class="headerlink" title="Altri Particolari"></a>Altri Particolari</h2><h3 id="I-Componenti-e-v-for"><a href="#I-Componenti-e-v-for" class="headerlink" title="I Componenti e v-for"></a>I Componenti e v-for</h3><p>Potete usare <code>v-for</code> sui componenti come fate su qualsiasi altro elemento:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Però, tale metodo non passerà nessun dato al componente perché ogni componente ha il proprio ambito isolato. Per passargli i dati tramite un ciclo <code>v-for</code> dovete utilizzare una sintassi del tipo:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span><br><span class="line">  <span class="attr">v-for</span>=<span class="string">"item in items"</span></span><br><span class="line">  <span class="attr">:item</span>=<span class="string">"item"</span></span><br><span class="line">  <span class="attr">:index</span>=<span class="string">"$index"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>La motivazione dietro tutto cioè è che non si vuole legare strettamente il componente al funzionamento di <code>v-for</code>, se si obbliga a rendere esplicita la provenienza dei dati, sarà più facile riutilizzare il componente.</p>
<h3 id="Authoring-dei-Componenti-Riutilizzabili"><a href="#Authoring-dei-Componenti-Riutilizzabili" class="headerlink" title="Authoring dei Componenti Riutilizzabili"></a>Authoring dei Componenti Riutilizzabili</h3><p>Quando si effettua authoring dei componenti, è buona cosa tenere a mente quando si vuole riutilizzare tale componente altrove. A volte può capitare di avere dei componenti poco riutilizzabili ma tenete a mente che è sempre meglio esporre un’interfaccia API pulita e chiara per ogni componente.</p>
<p>Le API per un componente in Vue.js si suddividono sostanzialmente in tre parti - props, eventi e slots:</p>
<ul>
<li><p><strong>Props</strong> ti permettono di ricevere dati dall’esterno del componente;</p>
</li>
<li><p><strong>Eventi</strong> ti permetto di attivare azioni che vengono distribuite all’esterno dei componenti;</p>
</li>
<li><p><strong>Slots</strong> ti permettono di inserire del contenuto esterno all’interno della struttura del componente.</p>
</li>
</ul>
<p>Con le scorciatoie dedicate per <code>v-bind</code> e <code>v-on</code>, l’intento è quello di fornire delle API chiare anche nel template:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span><br><span class="line">  <span class="attr">:foo</span>=<span class="string">"baz"</span></span><br><span class="line">  <span class="attr">:bar</span>=<span class="string">"qux"</span></span><br><span class="line">  @<span class="attr">event-a</span>=<span class="string">"doThis"</span></span><br><span class="line">  @<span class="attr">event-b</span>=<span class="string">"doThat"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"main-text"</span>&gt;</span>Ciao!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Componenti-Asincroni"><a href="#Componenti-Asincroni" class="headerlink" title="Componenti Asincroni"></a>Componenti Asincroni</h3><p>In applicazioni molto grosse, è utile poter dividere il tutto in piccole parti, e caricare solo i componenti quanto solo veramente necessari. Per facilitare questo processo, Vue.js vi permette di definire i vostri componenti in una funzione factory che automaticamente risolverà e renderizzerà i componenti per voi quando richiesti:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;Sono Asincrono!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>La funzione factory riceve un callback chiamato <code>resolve</code>, il quale dovrebbe essere chiamato quando avete ricevuto la definizione del componente dal server. Potete anche chiamare <code>reject(reason)</code> per indicare un caricamento fallito, con tanto di moticazione. Nel nostro esempio il <code>setTimeout</code> dimostra come il componente venga caricato un secondo dopo in modo asincrono. La logica di caricamento è totalmente gestita da voi. Un consiglio è quello di utilizzare i componenti asincroni ed la <a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">funzione code-splitting di Webpack</a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Usando require il vostro codice saprà che</span></span><br><span class="line">  <span class="comment">// webpack è necessario per importare il componente in modo</span></span><br><span class="line">  <span class="comment">// asincrono ed automatico.</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Convenzione-sui-Nomi-da-usare"><a href="#Convenzione-sui-Nomi-da-usare" class="headerlink" title="Convenzione sui Nomi da usare"></a>Convenzione sui Nomi da usare</h3><p>Alcuni elementi, come le direttive ed i componenti, vengono renderizzari dentro il codice HTML sotto forma di attributi oppure tag personalizzati. Dato che gli attributi ed i tag in HTML sono <strong>case-insensitive</strong>, è buona cosa utilizzare la sintassi kebab-case piuttosto che camelCase, quest’ultima potrebbe recare confusione.</p>
<p>Vue.js supporta l’uso di camelCase o PascalCase per le direttive o i componenti, e cercherà nel migliore dei modi di tradurle in kebab-case:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Nella definizione di un componente</span></span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="comment">// registri il componente tramite camelCase</span></span><br><span class="line">  myComponent: &#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- utilizza il kebab-case nel template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Questo approccio funzione bene con le <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_6" target="_blank" rel="external">scorciatoie pr oggetti in ES6</a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PascalCase</span></span><br><span class="line"><span class="keyword">import</span> TextBox <span class="keyword">from</span> <span class="string">'./components/text-box'</span>;</span><br><span class="line"><span class="keyword">import</span> DropdownMenu <span class="keyword">from</span> <span class="string">'./components/dropdown-menu'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// usati nel template come &lt;text-box&gt; e &lt;dropdown-menu&gt;</span></span><br><span class="line">    TextBox,</span><br><span class="line">    DropdownMenu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Componenti-Ricorsivi"><a href="#Componenti-Ricorsivi" class="headerlink" title="Componenti Ricorsivi"></a>Componenti Ricorsivi</h3><p>Un componente può invocare se stesso in modo ricorsivo, però questo è possibile solo quando l’opzione <code>name</code> è specificata:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> StackOverflow = Vue.extend(&#123;</span><br><span class="line">  name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">  template:</span><br><span class="line">    <span class="string">'&lt;div&gt;'</span> +</span><br><span class="line">      <span class="comment">// invocazione ricorsiva</span></span><br><span class="line">      <span class="string">'&lt;stack-overflow&gt;&lt;/stack-overflow&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Una chiamata come quella dell’esempio sopra, porterebbe il vostro codice ad un errore del tipo “max stack size exceeded”, assicuratevi che le chiamate ricorsive siano sempre monitorate da qualche condizione che ne limiti la creazione stessa. Quando registrate un componente a livello globale tramite <code>Vue.component()</code>, l’ID viene automaticamente generato e associato alla opzione <code>name</code>.</p>
<h3 id="Istanze-Frammentate"><a href="#Istanze-Frammentate" class="headerlink" title="Istanze Frammentate"></a>Istanze Frammentate</h3><p>Quando si utilizza l’opzione <code>template</code> di un componente, essa andrà a sostituire il contenuto del componente per ogni istanza Vue nella quale il componente viene chiamato. A conoscenza di ciò è consigliato sempre tenere un unico livello di root per tutti i componenti di una singola istanza Vue.</p>
<p>Invece di un template del genere:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>root node 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>root node 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>E’ consigliato questo:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  Un solo livello di Root!</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>node 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>node 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Ci sono molte situazione che possono trasformare una istanza Vue in un’<strong>istanza frammentata</strong>:</p>
<ol>
<li>Il template contiene più elementi di root assieme.</li>
<li>Il template contiene solo testo.</li>
<li>Il template contiene un altro componente (il quale potrebbe essere frammentato):</li>
<li>Il template contiene solo una direttiva come <code>&lt;partial&gt;</code> oppure una vou-route <code>&lt;router-view&gt;</code>.</li>
<li>Il template contiene un elemento di root con delle condizioni tipo <code>v-if</code> o <code>v-for</code>.</li>
</ol>
<p>La ragione per la quale tutte questi punto possono portare ad una istanza frammentata è che non si riesce più a definire quale sia l’elemento di rotto principale, questo costringe Vue a gestire tutto il contenuto del DOM come un template. Questo non impedirà di renderizzare il tutto correttamente ma non avendo un elemento di root l’opzione <code>$el</code> punterà ad un elemento non corretto, di solito un elemento del DOM testuale.</p>
<p>La cosa più importante di ciò è che <strong>verranno ignorate tutte le direttive non di controllo, tutti gli attributi che non sono prop e tutte le transizioni dei componenti</strong>, perché non c’è nessun elemento di root definito al quale legarle:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Non funzionerà --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">example</span> <span class="attr">v-show</span>=<span class="string">"ok"</span> <span class="attr">transition</span>=<span class="string">"fade"</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Funzionerà, i prop funzionano --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">example</span> <span class="attr">:prop</span>=<span class="string">"someData"</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- il controllo funziona ma senza transizioni--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">example</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Ci sono dei casi nei quali le istanze frammentate sono l’unico modo di operare, in generale però è sempre meglio evitarle specificando un singolo elemento di root. Oltre alle motivazioni citate precedentemente, avere un elemento di root migliora anche le prestazioni.</p>
<h3 id="Template-Inline"><a href="#Template-Inline" class="headerlink" title="Template Inline"></a>Template Inline</h3><p>Quando si utilizzano i template inline, lo si fa tramite l’utilizzo di un attributo speciale chiamato <code>inline-template</code>, questo permette di utilizzare il contenuto scritto nel componente come unico contenuto per il suo template:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Questi due elemento sono compilati come parte del template del componente<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Senza inclusione da parte di un eventuale componente padre<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Comunque sia gli <code>inline-template</code> rendono lo scope del vostro template più difficile da definire, e rendono il contenuto del template impossibile da salvare in cache. E’ sempre consigliato salvare e definire il template internamente al componente tramite l’opzione <code>template</code>.</p>

    
    <div class="footer">
      Trovato un errore e vuoi contribuire alla documentazione?
      <a href="https://github.com/vuejs/it.vuejs.org/blob/master/src/guide/components.md" target="_blank">
        Modifica questa pagina su Github!
      </a>
    </div>
</div>

                
            </div>
            <script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
            <script src="/js/smooth-scroll.min.js"></script>
            <script src="/js/common.js"></script>
        

        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                FastClick.attach(document.body);
            }, false);
        </script>
    </body>
</html>
